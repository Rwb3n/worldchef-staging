PoC Plan #3: Client UI State + Server State Library Integration
(Mandated by ADR-WCF-004: Client UI State Management Strategy, contingent on mobile stack selection from PoC #1)
1. Objective:
Validate Seamless Integration & Clear Patterns: Ensure the chosen lightweight client UI state manager (Zustand for RN; Riverpod for Flutter - see Sec 2) works harmoniously with a dedicated server state management library (TanStack Query for RN; Riverpod's AsyncNotifier with custom logic or flutter_query for Flutter - see Sec 2). Establish clear, maintainable patterns for their interaction.
Verify Effectiveness for Core Use Cases: Confirm the combined approach effectively handles data fetching, caching, optimistic updates, cache invalidation, error handling, and basic offline awareness for API interactions.
Assess Developer Experience (DX) & AI Effectiveness: Evaluate learning curve, boilerplate, ease of use, debuggability, and how well AI assists in implementing these combined patterns.
Confirm Performance: Ensure no noticeable performance degradation (re-renders, UI jank).
Assess Testability: Evaluate the design's amenability to unit/widget testing for stateful logic.
2. Scope & Environment:
Client Stack: Implemented on the mobile stack chosen from PoC #1 (ADR-WCF-001a).
Target Libraries (To be finalized PRE-PoC based on research & PoC #1 outcome):
UI State:
React Native (if chosen): Zustand.
Flutter (if chosen): Riverpod (using Notifier / AsyncNotifier for state).

Server State:
React Native (if chosen): TanStack Query (React Query v5+).
Flutter (if chosen): Riverpod's  A definitive choice for Flutter's server state approach must be made before this PoC begins.


Key Flows to Implement (Identical logic for both potential stacks):
Recipe List Retrieval & Caching: Fetch list (paginated, e.g., page 1 of 10 items), display, cache. Implement "pull-to-refresh" (refetch page 1, potentially invalidate entire list).
Recipe Detail Retrieval & "Like" Action (Optimistic Update): Fetch details, display. Implement "like" button:
Optimistically update UI (using server state lib's features or UI state for immediate feedback).
API call. Success: confirm UI, invalidate/update relevant caches (list & detail). Failure: revert UI, show error toast.

UI-Only State Interaction & Persistence:
Global theme toggle (light/dark), persisted using chosen offline mechanism (see below).
Global isOffline boolean flag (UI state) that disables server state queries and shows an offline banner.

Basic A11y & i18n in one UI component using state:
A button whose label changes based on state (e.g., "Like" / "Unlike") and is internationalized.
Verify accessibilityLabel / Semantics.label updates correctly with state changes.


API Endpoint Mocks:
Minimal Fastify stub server (or msw for RN / dio_mock_interceptor for Flutter if preferred for http client level) providing:
GET /api/v1/recipes?page=X&limit=Y
GET /api/v1/recipes/{id} (includes likes_count, is_liked_by_user)
POST /api/v1/recipes/{id}/like & DELETE /api/v1/recipes/{id}/like (toggles like, returns updated recipe detail or new likes_count & is_liked_by_user).

Mock server must simulate realistic API latencies (e.g., 80-150ms) and be configurable to return various success/error responses (4xx, 5xx) for testing error handling.

Offline Storage for UI State Persistence: AsyncStorage/MMKV for RN; shared_preferences or hive for Flutter (to persist theme choice).
Development Tools: React DevTools Profiler, TanStack Query Devtools; Flutter DevTools (Performance, Inspector, Provider/Riverpod tab).
3. Step-by-Step Plan (Iterative for each feature within the PoC):
A. Project Setup & Library Integration (Time-boxed: 1 day human + AI):
Minimal PoC project. Install/configure UI & Server state libs. Setup mock API. Define TypeScript/Dart interfaces for RecipeSummary, RecipeDetail. Minimal CI (lint/format).

B. AI-Assisted Implementation with Human Oversight (Core PoC work, time-boxed per feature):
Define UI State Store(s): (e.g., useUIStore for Zustand; Riverpod NotifierProvider for theme/offline). AI generates initial based on prompt; human refines, adds persistence for theme.
Implement API Interaction & Server State Hooks: AI generates initial query/mutation hooks based on prompts detailing optimistic updates, cache invalidation needs. Human refines error handling, onMutate/onError/onSettled logic.
Implement Screens: AI generates UI based on Figma snippets. Human integrates state logic, ensures NFR stubs (A11y labels from i18n strings, offline flag usage).
A11y Detail: Verify dynamic updates (e.g., "Liked" button state) correctly update semantic labels.
i18n Detail: Test one pluralized string based on state (e.g., "{likeCount} likes").


C. Performance, Behavior, DX Validation (Ongoing, dedicated time at end):
Cache Behavior: Test scenarios (List→Detail→Like→Back to List).
Offline Simulation: Verify query disabling, UI banner.
Re-renders (Profiler): Measure impact of theme toggle, likes, list refresh.
Latency (Optimistic Update): Instrument code (Date.now() / Stopwatch) to measure tap → optimistic UI change (<50ms target) and tap → server confirmation/rollback.
Error Handling: Test API error scenarios, confirm UI rollback and error display.
Testability Sketch: For one key piece of logic (e.g., "like" mutation), sketch out unit test cases.

4. AI Interaction & Time Tracking:
Standardized Prompts: Use pre-defined prompt templates (appendix to PoC plan) for generating similar features (e.g., "Create a TanStack Query mutation for X with optimistic update pattern Y").
Log AI Metrics: "AI generation time" (prompt to first usable snippet), "Prompt Iteration Count."
Log Human Hours: Detailed breakdown (prompting, review, debug, direct coding, NFR integration) via shared timesheet/tool.
5. Success Criteria & Evaluation (Quantitative Targets Finalized Pre-PoC):
A. Seamless Integration & Clear Patterns:
Optimistic updates for "like" fully functional, including correct cache invalidation and UI reconciliation.
Patterns for UI state ↔ server state interaction are clear, maintainable, not overly complex (qualitative rubric, code review).

B. Performance:
Optimistic UI update perceived instantaneously (<50ms from tap to UI change).
Full mutation cycle (tap → server confirm/rollback) responsive (e.g., p90 < 300-500ms with mock API latency).
No unnecessary global re-renders from local UI state changes (theme toggle) or server state updates.

C. Offline Handling: Queries correctly disabled/UI reflects offline state when isOffline flag is true.
D. Developer Experience & AI Effectiveness (Qualitative Rubric + Quantitative AI/Human Hours):
Ease of implementation, clarity of debugging, boilerplate amount. AI effectiveness in generating correct/idiomatic combined patterns.

E. Testability Assessment: Conceptual testability of key logic deemed straightforward by PoC lead.
F. Basic A11y/i18n Stubs: Implemented successfully.
6. "Showstopper" / Failure Conditions for this PoC:
Persistent inability to implement robust optimistic updates with reliable cache invalidation using the chosen libraries.
Interaction patterns between UI and server state libraries are consistently convoluted, error-prone, or require excessive boilerplate.
Significant performance issues (UI jank, excessive re-renders) directly attributable to the state management approach.
AI significantly struggles to generate usable code for the combined patterns, requiring >70% human rewrite for core logic.
Inability to gracefully handle isOffline state for server queries.
If showstoppers occur, ADR-WCF-004 will be revisited (primary alternative: Unified RTK + RTK Query, requiring its own PoC).
7. Deliverables & Documentation from PoC Phase:
PoC Mobile App Code: Focused app on chosen stack. Include AI prompt log for key features.
PoC Evaluation Report:
Implementation summary for each flow. Assessment against success criteria.
Profiler screenshots/data (raw traces if possible). Video/GIFs of key interactions.
Quantitative metrics (latencies, AI/Human hours). Qualitative rubric scores.
Learnings, "gotchas," recommended patterns for Zustand+ServerLib (or equivalent).
Clear Recommendation: Confirm/refute suitability of ADR-WCF-004 decision. If confirmed, provide refined patterns.


