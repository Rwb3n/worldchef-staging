ADR-WCF-004: Client UI State Management Strategy
Status: VALIDATED (PoC #3 confirmed)
Date: 2025-06-13 (Initial creation)
Date Validated: 2025-06-13
Authors: WorldChef Mobile Team

1. Context and Problem Statement
The WorldChef Flutter mobile client (ADR-WCF-001a) requires a coherent, scalable, and testable strategy for managing local UI state (theme, offline flag, transient UI flags) and remote server state (data retrieved from the Supabase-backed API – ADR-WCF-003 & ADR-WCF-001d). Historical pitfalls in mobile projects include state bloat, unclear separation of concerns, poor cache invalidation, and brittle optimistic updates. This ADR establishes the official Flutter state-management stack and the guiding patterns that PoC #3 will validate empirically.

2. Decision Drivers
• Flutter Selected (ADR-WCF-001a): Leverage idiomatic, ecosystem-aligned tooling.
• Performance & UX: Seamless, instantaneous optimistic updates (<50 ms) and minimal jank.
• Developer Experience & AI Synergy: Libraries/patterns must be highly automatable by AI with low boilerplate.
• Testability: 100 % reliable widget/unit tests (PoC #1 outcome) must extend to state logic.
• Offline Capability: First-class pattern for offline flag & persisted UI state.
• Scalability: Clear migration path from MVP features to growing data complexity.
• Consistency with Backend Caching Semantics: Align invalidation with Supabase caching constraints.

3. Considered Options
A. Riverpod 2.x
   • UI State: NotifierProvider / StateNotifierProvider
   • Server State: AsyncNotifierProvider (built-in async cache) + dio HTTP client
   Pros: Compile-time safety, granular rebuild control, global provider graph tooling, strong testing, large community.
   Cons: Slight learning curve, manual cache invalidation API.

B. flutter_query (Flutter wrapper of TanStack Query semantics)
   Pros: Familiar React-Query-like API, built-in optimistic updates.
   Cons: Smaller ecosystem, additional dependency layer, less compile-time safety.

C. BLoC + http
   Pros: Historic pattern familiarity.
   Cons: Boilerplate heavy, lower AI generation success (<60 %).

D. Redux Toolkit-like solutions (e.g., AsyncRedux, katana_state)
   Pros: Predictable state tree.
   Cons: Verbose, unfriendly DX, poor async cache semantics.

4. Decision
**Chosen Option: Riverpod 2.x**
UI State → NotifierProvider / StateNotifier (synchronous)
Server State → AsyncNotifierProvider with dio for network calls
Persistence → Hive for lightweight key-value storage (theme) & shared_preferences fallback

Justification:
• Highest AI code-generation success in preliminary tests (≈92 %).
• Granular rebuilds meet performance targets.
• Strong testing utilities align with 100 % test reliability goal.
• ProviderScope-level overrides simplify offline simulations & test doubles.
• Active, growing ecosystem; maintained by core Flutter community members.

5. Architectural Patterns & Guidelines
5.1 Separation of Concerns
• UI ↔ UI Store (Notifier) ↔ Widgets – Pure UI state, no I/O.
• Server State Providers (AsyncNotifier) handle fetch/mutation logic, caching, optimistic updates.
• Widgets consume providers via `ref.watch` for reactive updates.

5.2 Optimistic Update Workflow (Like Recipe)
1. User taps 👍 → Update local cache via `update((state) => …)` inside mutation's `onMutate`.
2. Persist optimistic UI via provider state; emit updated like count.
3. Send HTTP POST; on success – reconcile; on error – rollback & show toast.

5.3 Cache Invalidation & Consistency
• Each list/detail provider keyed by ID/page (family providers).
• After successful mutation, call `ref.invalidate(listProvider)` & update detail cache.
• Global helper `invalidateRelatedCaches(ids…)` aids AI generation.

5.4 Offline Handling
• Global `offlineProvider` (Notifier) toggled via connectivity listener.
• Server state providers early-return cached data when offline & skip network.
• UI shows banner when `offlineProvider.state == true`.

5.5 Persistence Rules
• Theme preference & onboarding flags stored via Hive box `ui_prefs`.
• Hydrate providers in `main()` before runApp.

5.6 Testing Strategy
• Widget tests use `ProviderScope(overrides: …)` to inject fake repositories.
• State tests verify optimistic update rollback scenarios via `AsyncValue.guard`.

6. Consequences
Positive:
✓ High performance, fine-grained rebuild control.
✓ Minimal boilerplate via code-generation `riverpod_lint` & AI prompts.
✓ Comprehensive testing story.
✓ Native async/await ergonomics, no callback hell.
Negative / Trade-offs:
• Learning curve vs. simple setState.
• Manual cache invalidation – mitigated with helper utilities.
• Potential dependency on Riverpod ecosystem health (mitigate by periodic review).

7. Validation / Success Metrics (Measured in PoC #3)
• Optimistic like update visible <50 ms (Median on mid-range device).
• Mutation round-trip p90 <300 ms with mock latency 80-150 ms.
• No unnecessary widget rebuilds (Flutter DevTools → ≤2 renders on like flow).
• AI code generation first-iteration success ≥60 % for provider/mutation patterns.
• All unit/widget tests pass reliably in CI (≥98 %).
• Offline flag disables queries & shows banner within 200 ms of connectivity change.

8. Review / Revisit
• Immediate: Upon completion of PoC #3 – update Status to **VALIDATED** or **RECONSIDER**.
• If optimistic update patterns prove error-prone (>5 % rollback failures) – explore flutter_query.
• Quarterly: Assess Riverpod ecosystem health & version upgrades.
• Major feature introductions (e.g., real-time streaming) may trigger re-evaluation.

Human Accountability: The WorldChef Mobile Team is responsible for implementing and validating this strategy, guided by AI support, and for updating this ADR post-PoC #3.

9. Validation Outcome (PoC #3)
PoC #3 achieved all success metrics:
• 100 % CI pass rate (43/43 tests) – see test_run_g70.log (SHA A47DBE27…D740)
• Optimistic-update median 36 ms, p90 mutation latency 210 ms
• AI first-iteration success 87.5 %
• Offline-banner latency 120 ms

Evidence artefacts stored in `docs/poc3_client_ui_state_integration/stage2_validation/`.

---
Previous status line retained above for audit. 