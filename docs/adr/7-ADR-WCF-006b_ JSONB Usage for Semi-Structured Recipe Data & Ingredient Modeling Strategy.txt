ADR-WCF-006b: JSONB Usage for Semi-Structured Recipe Data & Ingredient Modeling Strategy
Status: ACCEPTED
Date: 2025-06-01 (Final version incorporating comprehensive feedback on ingredient normalization, JSONB validation, indexing, update strategies, versioning, and optimistic locking for MVP)
Authors: AI Dev Team
1. Context and Problem Statement
Following ADR-WCF-006a (Core Relational Structure), this ADR details the strategy for storing steps and nutrition data as JSONB within the recipes table. Crucially, it also finalizes the decision to use a normalized relational model for  to support essential MVP search functionality. This ADR defines the structures, validation, indexing, and interaction patterns for these fields, balancing MVP velocity with core feature requirements and data integrity.
2. Decision Drivers
Core Ingredient Searchability (MVP): Enable users to find recipes based on ingredients.
Flexibility & Ordered Lists (Steps, Nutrition): Accommodate variable attributes and natural ordering.
Simplified Schema (where appropriate): Balance relational rigor with MVP development speed.
Performance: Efficient recipe display and reasonable performance for MVP search.
Developer Experience: Intuitive data structures.
Schema Evolution & Data Integrity: Manage changes and ensure data quality.
3. Decision
For  A Normalized Relational Model is chosen (detailed below).
Rationale: Ingredient-based search is a core MVP feature. Normalization provides superior searchability, vocabulary management, and data integrity for ingredients compared to JSONB. The increased initial CRUD complexity in the Fastify API is accepted for this critical functionality.

For  These will use JSONB within the recipes table.
Rationale: Their ordered list nature (steps) and variable key-value structure (nutrition) are well-suited to JSONB. Complex cross-recipe querying on their internal details is not an MVP priority, making JSONB efficient for display and storage.

Optimistic Locking for Recipes: The recipes table will include a version INT NOT NULL DEFAULT 1 column to handle concurrent edits. The Fastify API must implement check-and-set logic using this version.
JSONB Schema Versioning: A top-level recipes.json_content_version INT DEFAULT 1 column will track structural versions of steps and nutrition JSONB fields, enabling graceful handling of future schema evolutions by application logic.
Defined Structures & Handling for MVP:
A. Relational 
 Table:
id UUID PRIMARY KEY DEFAULT uuid_generate_v4()
name TEXT NOT NULL UNIQUE (Normalized: lowercase, singular. Application logic enforces this on insert.)
name_fts_vector TSVECTOR GENERATED ALWAYS AS (to_tsvector('english', name)) STORED
created_at TIMESTAMPTZ DEFAULT NOW()
CREATE INDEX idx_ingredients_name_fts_gin ON ingredients USING GIN (name_fts_vector);
CREATE INDEX idx_ingredients_name_trgm ON ingredients USING GIN (name gin_trgm_ops);
Note on Synonyms/Aliases: For MVP, strict normalized names are used. A future ADR will address advanced synonym/alias management (e.g., ingredient_aliases table) if robust handling of "olive oil" vs "EVOO" becomes critical.

 Table (Junction Table):
id UUID PRIMARY KEY DEFAULT uuid_generate_v4()
recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE
ingredient_id UUID NOT NULL REFERENCES ingredients(id) ON DELETE RESTRICT
quantity NUMERIC(10,2)
unit VARCHAR(50)
notes TEXT
original_user_input TEXT (User's exact input for this line)
display_order INT NOT NULL
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
CONSTRAINT uq_recipe_ingredient_order UNIQUE (recipe_id, display_order) (Ensures unique step order per recipe)
CONSTRAINT uq_recipe_ingredient_item UNIQUE (recipe_id, ingredient_id, COALESCE(notes, '')) (Prevent exact duplicate ingredient line; notes distinguish if same item used differently. May adjust based on UX for adding same ingredient multiple times).
CREATE INDEX idx_recipe_ingredients_recipe_id ON recipe_ingredients(recipe_id);
CREATE INDEX idx_recipe_ingredients_ingredient_id ON recipe_ingredients(ingredient_id);
Ingredient Parsing: The Fastify API is responsible for complex parsing of free-text ingredient strings from users into these structured fields (name normalization, quantity/unit extraction). This is a significant implementation task.

B. 
Type: Array of objects.
Object Schema (referenced by recipes.json_content_version = 1):
[
  { "id": "uuid_v4_step", "step_number": 1, "description": "Preheat oven...", "image_url": "optional.jpg" }
]
content_copy
download
Use code with caution.Json

Validation (PostgreSQL 
ALTER TABLE recipes ADD CONSTRAINT chk_steps_schema CHECK (
    jsonb_typeof(steps) = 'array' AND
    (jsonb_array_length(steps) = 0 OR -- handles empty array
     (
        jsonb_path_exists(steps, '$[*].id') AND           -- Each step has an id
        jsonb_path_exists(steps, '$[*].step_number') AND  -- Each step has a step_number
        jsonb_path_exists(steps, '$[*].description') AND  -- Each step has a description
        -- Check if all step_numbers are unique within the array for this recipe
        (SELECT bool_and(is_unique) FROM (
            SELECT count(*) = 1 AS is_unique
            FROM jsonb_array_elements(steps) AS elem
            GROUP BY elem->>'id' -- Assuming 'id' within step object should be unique for the step
        ) AS id_uniqueness) AND
        (SELECT bool_and(is_unique_num) FROM (
             SELECT count(*) = 1 AS is_unique_num
             FROM jsonb_array_elements(steps) AS elem
             GROUP BY elem->>'step_number'
        ) AS num_uniqueness)
     ))
);
content_copy
download
Use code with caution.SQL
(Note: The step_number uniqueness check above is complex for a CHECK constraint and might be better enforced robustly at the application layer (Fastify API) before saving, with a simpler DB check for basic structure. For MVP, Fastify will ensure step_number uniqueness per recipe.) A simpler DB check:
ALTER TABLE recipes ADD CONSTRAINT chk_steps_basic_schema CHECK (
    jsonb_typeof(steps) = 'array' AND
    (jsonb_array_length(steps) = 0 OR
     (
        jsonb_path_exists(steps, '$[*].id') AND
        jsonb_path_exists(steps, '$[*].step_number') AND
        jsonb_path_exists(steps, '$[*].description')
     ))
);
content_copy
download
Use code with caution.SQL

C. 
Type: Single object.
Object Schema (referenced by recipes.json_content_version = 1):
{
  "calories_kcal": 550, "protein_g": 25.5, /* ... other standard numeric nutrients ... */
  "source_info": { 
      "type": "Edamam", // "Edamam", "UserCalculated", "USDA"
      "api_version": "v2.3", // If from external API
      "retrieval_date_utc": "YYYY-MM-DDTHH:MM:SSZ" // Date of data retrieval/calculation
  },
  "user_notes": "Based on specific brand of X used." // Optional user notes about nutrition
}
content_copy
download
Use code with caution.Json

Validation (PostgreSQL 
ALTER TABLE recipes ADD CONSTRAINT chk_nutrition_schema CHECK (
    jsonb_typeof(nutrition) = 'object' AND
    (nutrition IS NULL OR -- Allow nutrition to be initially null
    (
        (nutrition->'source_info' IS NOT NULL AND
         nutrition->'source_info' ? 'type' AND
         nutrition->'source_info' ? 'retrieval_date_utc'
        ) AND
        -- Example: Ensure calories_kcal is non-negative if present
        ((nutrition->>'calories_kcal')::numeric IS NULL OR (nutrition->>'calories_kcal')::numeric >= 0) AND
        ((nutrition->>'protein_g')::numeric IS NULL OR (nutrition->>'protein_g')::numeric >= 0) -- etc. for other key nutrients
        -- Further semantic validation (e.g. if type='Edamam' then api_version must exist) in Fastify.
    ))
);
content_copy
download
Use code with caution.SQL

Updating Nested JSONB Elements (
For MVP, recipe edits updating the steps array will involve the Fastify API rewriting the entire array. This strategy prioritizes simplicity for initial implementation. Performance will be monitored; if rewriting large step arrays becomes a bottleneck for frequently edited recipes, partial updates using jsonb_set (with careful path and index management) will be investigated post-MVP.
JSONB Size & Indexing:
steps array: Soft limit of ~50-75 items. Application logic may warn or paginate for very long recipes.
nutrition object is generally small.
No GIN index on steps or nutrition for MVP, as primary interaction is full retrieval.
5. Rationale
This strategy addresses critical feedback by prioritizing core recipe app functionality (ingredient search) while retaining JSONB's flexibility for suitable fields.
Normalized  This is a crucial shift. Relational ingredients and recipe_ingredients tables enable robust ingredient-based search, filtering, and future "what can I make" features from MVP, which are fundamental to user experience. The increased Fastify CRUD complexity is accepted for this vital functionality.
JSONB for  These remain suitable for JSONB. Steps benefit from natural ordering and flexibility for optional attributes (like images). Nutrition benefits from a flexible key-value structure and clear provenance tracking via source_info. Complex cross-recipe querying on their internal details is not an MVP priority.
Data Integrity & Validation:
Relational model for ingredients provides strong integrity.
DB-level CHECK constraints for JSONB steps and nutrition enforce basic structural validity. Detailed semantic validation (e.g., ensuring units are valid, nutrient values are plausible) resides in the Fastify API.

Schema Evolution: recipes.json_content_version allows the application to handle different internal JSONB structures for steps and nutrition over time.
Optimistic Locking: The recipes.version column (ADR-WCF-006a) provides a mechanism for Fastify to handle concurrent edits when updating recipes, including their relational ingredients or JSONB fields.
Performance: Relational ingredients with FTS/trigram indexes are performant for search. JSONB for steps/nutrition is performant for single-recipe display.
6. Consequences
Positive Consequences / Benefits:
Robust Ingredient-Based Search and Filtering from MVP.
Manages a clean, global vocabulary of normalized ingredient names (basis for future synonym/alias system).
Flexible schema for steps and nutrition.
Efficient retrieval of steps/nutrition for single recipe display.
Clear JSONB structures with basic DB validation and a versioning path.
Optimistic locking capability for recipe edits.
Negative Consequences / Trade-offs / Risks:
Increased Initial Development Effort for Ingredient Management: Fastify API logic for parsing free-text user ingredient input, normalizing names, matching/creating ingredients records, and managing recipe_ingredients join table entries is significantly more complex than handling a simple JSONB array for ingredients. This is the primary trade-off.
Ingredient Parsing Complexity (NLP Challenge): Accurately parsing diverse free-text ingredient strings ("2 large eggs, beaten lightly") into structured quantity, unit, name, notes is a non-trivial Natural Language Processing (NLP) problem. For MVP, this parsing logic in Fastify might be rule-based and support common patterns, with graceful fallback for unparseable lines.
Data Integrity Within JSONB  Still relies heavily on Fastify API for detailed semantic validation beyond basic structural DB checks.
Migration Path for  If these fields ever require full normalization from JSONB, it will be a considerable data migration task.
7. Validation / Success Metrics
PoC (Early Cycle 1): Successful implementation of recipe CRUD in Fastify, demonstrating:
Effective parsing of common free-text ingredient formats into the normalized structure.
Reliable creation/update of ingredients and recipe_ingredients records.
Correct storage and retrieval of JSONB steps and nutrition data.

Ingredient-based search (e.g., "recipes containing X and Y") is functional and performs acceptably for MVP scale (e.g., <500ms response for typical searches on 10k recipes).
DB CHECK constraints prevent storage of grossly malformed JSONB.
recipes.version effectively prevents lost updates in simulated concurrent edit scenarios.
8. Review / Revisit
After Cycle 1: Once recipe CRUD with normalized ingredients and JSONB steps/nutrition is heavily used. Critically evaluate the complexity and reliability of the ingredient parsing logic in Fastify. Assess search performance.
If ingredient parsing in Fastify proves too unreliable or slow to develop for diverse user inputs. (Contingency: Simplify to more structured ingredient input fields in UI, or explore third-party ingredient parsing APIs if budget allows).
If requirements for complex, performant cross-recipe querying on specific attributes 
When planning an advanced global ingredient database with synonym management, unit conversions, or richer attributes. This would build upon the existing normalized ingredients table.

