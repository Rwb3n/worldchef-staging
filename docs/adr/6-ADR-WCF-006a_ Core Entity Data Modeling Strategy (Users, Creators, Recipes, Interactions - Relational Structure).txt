ADR-WCF-006a: Core Entity Data Modeling Strategy (Users, Creators, Recipes, Interactions - Relational Structure)
Status: ACCEPTED
Date: 2025-06-01 (Final version incorporating comprehensive feedback on user profiles, soft deletes, critical relationships, indexing, operational considerations, and risk management for MVP)
Authors: AI Dev Team
1. Context and Problem Statement
WorldChef's success relies on a well-designed data model for its core entities: Users, Creators, Recipes, and their interactions (likes, collections, follows). This ADR documents the decision to use a primarily relational approach within PostgreSQL (via Supabase - ADR-WCF-001d) for these entities, focusing on data integrity, queryability for MVP features, and a foundation for future growth. Specific decisions on using JSONB for recipe ingredients/steps are deferred to ADR-WCF-006b.
General Principles:
UUID Generation: Primary keys of type UUID will default to uuid_generate_v4().
Timestamps: TIMESTAMPTZ with default precision will be used.
Soft Deletes: Key entities (users, creators, recipes, recipe_collections) implement soft deletes (deleted_at TIMESTAMPTZ). Query simplification for application logic will be achieved via database views (e.g., CREATE VIEW active_recipes AS SELECT * FROM recipes WHERE deleted_at IS NULL;). Cascading soft deletes (e.g., when a creator is soft-deleted) will be handled by application logic in the Fastify API for MVP.
Auditing: MVP relies on Supabase DB logs and application logs (ADR-WCF-021). Detailed field-level audit tables are MVP+.
Schema Migrations: Managed via Supabase CLI. CREATE TYPE statements must precede table definitions using them.
2. Decision Drivers
Data Integrity & Consistency.
Efficient Querying of Complex Relationships (MVP features like likes, collections, follows).
Scalable Queries & Clear Schema Structure.
Leveraging PostgreSQL Strengths & Solid RLS Foundation.
Future Data Analysis & Reporting.
Alignment with Team SQL Preference.
Support for Core MVP Engagement Features.
3. Considered Options
Option 1: Primarily Relational Model using PostgreSQL (Chosen Option)
Description: Distinct tables for core entities and join tables for many-to-many relationships, with robust constraints, soft deletes, and denormalized counters.
Pros: Strong data integrity, powerful SQL querying, mature paradigm, good RLS foundation, supports MVP interactions well with performance considerations addressed.
Cons: Schema migrations require care. Application logic for cascading soft deletes needs robust implementation. Trigger logic for counters adds DB complexity.
Option 2: Primarily NoSQL/Document Model
(Rejected due to relational nature of core data, team SQL preference, and complexity of ensuring integrity/joins for MVP features).
4. Decision
The project will adopt a Primarily Relational Model (Option 1) using PostgreSQL for core entities and their interactions, incorporating soft deletes, denormalized counters (updated by database triggers), and database views for query simplification.
Key Table Structures for MVP:
 Table (Application User Profile):
id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE SET NULL (Allows auth deletion while app record remains, to be anonymized/managed per future Data Lifecycle & Compliance Plan)
email VARCHAR(255) UNIQUE NOT NULL (Synced from auth.users)
display_name VARCHAR(100)
avatar_url TEXT
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
deleted_at TIMESTAMPTZ DEFAULT NULL
Sync from 

 Table:
id UUID PRIMARY KEY DEFAULT uuid_generate_v4()
user_id UUID UNIQUE NOT NULL REFERENCES users(id) ON DELETE RESTRICT (Prevent user deletion if they are still an active creator; soft delete user first)
display_name VARCHAR(100) NOT NULL (Note: Not globally unique for MVP; client UI must provide additional context for disambiguation.)
bio VARCHAR(1000)
avatar_url TEXT
status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'suspended'))
recipes_count INT NOT NULL DEFAULT 0 (Denormalized, updated by trigger)
followers_count INT NOT NULL DEFAULT 0 (Denormalized, updated by trigger)
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
deleted_at TIMESTAMPTZ DEFAULT NULL

 ENUM Type (Must be created before 
CREATE TYPE recipe_status AS ENUM ('draft', 'published', 'archived', 'admin_removed');
content_copy
download
Use code with caution.SQL

 Table:
id UUID PRIMARY KEY DEFAULT uuid_generate_v4()
creator_id UUID NOT NULL REFERENCES creators(id) ON DELETE RESTRICT (Prevent creator deletion if they have active recipes; soft delete creator first, then handle recipes)
title VARCHAR(255) NOT NULL
slug VARCHAR(280) NOT NULL
description VARCHAR(5000)
media_url TEXT
prep_duration INTERVAL
cook_duration INTERVAL
servings INT CHECK (servings > 0)
cuisine VARCHAR(100)
region VARCHAR(100)
diet TEXT[]
time_of_day TEXT[]
is_paid BOOLEAN NOT NULL DEFAULT FALSE
status recipe_status NOT NULL DEFAULT 'draft'
published_at TIMESTAMPTZ
likes_count INT NOT NULL DEFAULT 0 (Denormalized)
collections_count INT NOT NULL DEFAULT 0 (Denormalized)
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
deleted_at TIMESTAMPTZ DEFAULT NULL
CONSTRAINT recipes_creator_id_slug_key UNIQUE (creator_id, slug)
Note on Deletion: 

 Table: (Triggers update recipes.likes_count)
user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
PRIMARY KEY (user_id, recipe_id)

 Table:
id UUID PRIMARY KEY DEFAULT uuid_generate_v4()
user_id UUID NOT NULL REFERENCES users(id) ON DELETE SET NULL (Note: Ownerless collections (user_id=NULL) resulting from user hard deletion from auth will be handled by application logic - e.g., archive/delete based on policy.)
name VARCHAR(100) NOT NULL
description VARCHAR(500)
is_public BOOLEAN NOT NULL DEFAULT FALSE
items_count INT NOT NULL DEFAULT 0 (Denormalized, recipes in this collection)
created_at TIMESTAMPTZ DEFAULT NOW()
updated_at TIMESTAMPTZ DEFAULT NOW()
deleted_at TIMESTAMPTZ DEFAULT NULL

 Table: (Triggers update recipe_collections.items_count and recipes.collections_count)
collection_id UUID NOT NULL REFERENCES recipe_collections(id) ON DELETE CASCADE
recipe_id UUID NOT NULL REFERENCES recipes(id) ON DELETE CASCADE
added_at TIMESTAMPTZ DEFAULT NOW()
PRIMARY KEY (collection_id, recipe_id)

 Table: (Triggers update creators.followers_count)
follower_user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE
creator_id UUID NOT NULL REFERENCES creators(id) ON DELETE CASCADE
created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
PRIMARY KEY (follower_user_id, creator_id)
Self-follows prevented by Fastify API application logic.

Indexing Strategy (Illustrative Key MVP Indexes, applied to underlying tables for view performance):
PKs automatically indexed. FKs will have B-tree indexes. All deleted_at columns indexed, often compositely.
CREATE INDEX idx_recipes_active_feed ON recipes(status, published_at DESC) WHERE status = 'published' AND deleted_at IS NULL;
CREATE INDEX idx_recipes_active_creator_feed ON recipes(creator_id, status, published_at DESC) WHERE status = 'published' AND deleted_at IS NULL;
CREATE INDEX idx_recipes_active_slug ON recipes(slug) WHERE deleted_at IS NULL; (If slug remains globally unique despite per-creator constraint)
GIN indexes on recipes.diet and recipes.time_of_day WHERE deleted_at IS NULL.
FTS index on recipes(title, description) WHERE deleted_at IS NULL AND status = 'published'.
Indexes on join tables for common access (e.g., recipe_likes(recipe_id)).
5. Rationale
This refined relational model provides a robust MVP foundation:
Dedicated  Balances decoupling with Supabase Auth integration.
Soft Deletes with View Abstraction: Enhances data management and simplifies application queries.
Denormalized Counters via Triggers: Optimizes read performance for frequently displayed stats.
Comprehensive Interaction Modeling: Supports core MVP engagement features (likes, collections, follows).
Strong Data Integrity: Achieved through ENUMs, INTERVAL types, and explicit constraints.
MVP Tagging & Ingredient Analytics: Pragmatic choices (arrays for tags, deferral of complex ingredient analytics) for MVP speed, with clear acknowledgment of future evolution paths and current limitations (e.g., JSONB ingredient query performance at scale for analytics).
6. Consequences
Positive Consequences / Benefits:
Robust data integrity and support for all core MVP features.
Improved data management and query performance through soft deletes (via views) and denormalized counters.
Enhanced queryability for durations and statuses.
Negative Consequences / Trade-offs / Risks:
Complexity of Soft Delete Cascades (Application Logic): Requires careful, robust implementation in Fastify for MVP.
User Profile Sync Reliability: Event-driven sync needs thorough testing and monitoring.
Trigger Complexity & Performance: Triggers for counters add DB load on writes and complexity. (Mitigation: Test thoroughly; consider async counter updates post-MVP if triggers become a bottleneck).
Array Tag Management: Global vocabulary changes remain deferred.
Data Retention/GDPR: Soft deletes are a step; a full "Data Lifecycle & Compliance Plan" is still needed.
7. Validation / Success Metrics
Schema supports all core MVP user stories.
Application queries via active_... views are performant and simplify logic.
Denormalized counters are accurate and measurably improve UI load times.
User profile sync operates reliably with appropriate monitoring and alerting.
Soft delete application logic correctly handles cascading scenarios for MVP.
8. Review / Revisit
After Cycle 2: Review performance of queries, trigger-based counters, soft delete management, and auth-user sync reliability.
If global tag management, advanced cross-recipe ingredient analytics, or features like Comments/Notifications/Recipe Versioning become high-priority.
To implement a comprehensive Data Lifecycle & GDPR Compliance Plan.
If trigger complexity or performance becomes a significant maintenance or operational burden.

