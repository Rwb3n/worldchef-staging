ADR-WCF-015: API Design Principles & Versioning
Status: ACCEPTED
Date: 2025-06-01 (Final version incorporating comprehensive feedback on RESTful conventions, validation, caching, pagination, error handling, HATEOAS, file uploads, and operational details)
Authors: WorldChef Backend Team
1. Context and Problem Statement
The WorldChef mobile client (ADR-WCF-001a) communicates with a Fastify backend API (ADR-WCF-001c, ADR-WCF-003). To ensure consistency, maintainability, excellent developer experience (for humans and AI), robust security, and a clear evolutionary path, this ADR establishes foundational API design principles and a versioning strategy. The API will primarily follow RESTful conventions using JSON.
2. Decision Drivers
Client Developer Experience (DX): Intuitive, predictable, easy-to-consume APIs.
Consistency: Uniformity across all endpoints.
Maintainability & Evolvability: Facilitate changes without unnecessarily breaking clients.
Performance: Encourage efficient data transfer and processing.
Security: Reinforce secure API practices.
Statelessness: Rely on tokens for authentication (ADR-WCF-005).
Clarity & Discoverability: Through standardized practices and documentation.
3. Decision: API Design Principles & Versioning Strategy
I. URI Structure & Naming Conventions:
Resource-Oriented: /recipes, /users/{userId}/collections. Identifiers are generally UUIDs.
Nouns, Not Verbs: /recipes.
Plural Nouns for Collections.
Path Parameters for Specific Resources: /recipes/{recipeId}.
Query Parameters for Filtering, Sorting, Pagination:
Filtering: GET /recipes?status=published&cuisine=italian. Parameter names are exact matches to resource fields where applicable (or clearly documented if mapped). For MVP /v1, filters generally support single values (e.g., status=published). Support for multiple values for the same filter key (e.g., ?diet=vegan&diet=vegetarian for OR, or ?diet=vegan,vegetarian for IN) will be explicitly documented per endpoint if supported.
Sorting: GET /recipes?sort=-published_at,title (comma-separated list; - prefix for descending). For MVP, support for at least a single sort field is required; multiple sort fields are an enhancement to be implemented consistently.
Pagination: GET /recipes?page=1&limit=20. Default limit=20, max limit=50.

Lowercase & Hyphenated Paths: /meal-plans.
II. HTTP Methods (Verbs):
GET: Retrieve resources. Idempotent. No side effects.
POST: Create new resources (e.g., /recipes). Or trigger actions on existing resources where idiomatic (e.g., /recipes/{recipeId}/like). Not generally idempotent unless Idempotency-Key is used.
PUT: Deferred for MVP. Full resource replacement is not a primary MVP use case.
PATCH: Preferred for partially updating existing resources for MVP. Uses JSON Merge Patch ( Client sends only fields to be changed. Note: For array fields, JSON Merge Patch replaces the entire array. Sending 
DELETE: Remove a resource (respecting soft-delete strategy - ADR-WCF-006a). Returns 204 No Content upon successful soft/hard deletion. Returns 404 Not Found if resource is already soft-deleted or doesn't exist.
HEAD: Supported for key GET /{resource}/{id} endpoints. Returns same headers as GET but no body, for checking existence or freshness (ETag, Last-Modified).
III. Request & Response Bodies:
JSON Exclusively: Content-Type: application/json, Accept: application/json.
Consistent JSON Structure:
camelCase for JSON property keys.
Date/Time Format: ISO 8601 in UTC (ending with 'Z', millisecond precision where applicable) e.g., {"createdAt":"2024-06-05T10:30:00.123Z", "updatedAt":"2024-06-06T12:45:30.500Z"}.
Collections & Pagination:
{
  "data": [ { /* resource object with minimal _links */ } ],
  "pagination": { 
    "currentPage": 1, "limit": 20, "totalItems": 198, "totalPages": 10,
    "prevPageUrl": null, // Full URL or null
    "nextPageUrl": "/v1/recipes?page=2&limit=20" // Full URL or null
  },
  "_links": { "self": "/v1/recipes?page=1&limit=20" } // Link to current page
}
content_copy
download
Use code with caution.Json
HTTP Link headers for pagination (rel="next", rel="prev", rel="first", rel="last") will also be provided.
Single Resources: The JSON object itself, potentially with a _links object for related resources or actions (minimal HATEOAS).
{ 
  "id": "abc123", "title": "Pasta", 
  /* ...other fields... */ 
  "_links": { "self": "/v1/recipes/abc123", "creator": "/v1/creators/def456" } 
}
content_copy
download
Use code with caution.Json

201 Created responses include Location header and created resource body. PATCH responses return full updated resource.

Partial Responses/Field Selection: Support optional fields query parameter (e.g., GET /recipes?fields=id,title,publishedAt) on GET requests. Fastify API validates requested fields against an allow-list for each resource to prevent exposing sensitive data. Invalid/disallowed fields in the fields parameter result in a 400 Bad Request or are silently ignored (former preferred with clear error detail).
IV. HTTP Status Codes: (Standard usage, key examples listed in previous draft remain valid). 405 Method Not Allowed for unsupported methods on existing resources.
V. Error Handling & Correlation ID:
Standardized JSON Error Response (as previous draft, including correlationId).
Correlation ID ( Clients may send an X-Correlation-ID (UUID v4) header. If present and valid, the server echoes it in the response header. If absent or invalid, Fastify generates a new UUID v4, uses it for logging, and returns it in the X-Correlation-ID response header and in the correlationId field of JSON error bodies.
VI. Authentication & Authorization: As per ADR-WCF-005.
VII. API Versioning: /v1/... (URI Path Versioning). Non-breaking changes communicated via API changelog/updated OpenAPI spec.
VIII. Idempotency: Mandatory Idempotency-Key: <uuid_v4_value> header for critical POST operations (e.g., subscription creation - ADR-WCF-007). Server stores/checks key for a defined window.
IX. Caching & Conditional Requests:
GET endpoints for cacheable resources include Cache-Control: public, max-age=<seconds> and ETag.
Support If-None-Match request header; return 304 Not Modified if ETag matches.
X. Request Validation (Schema-First):
All Fastify routes must define JSON schemas for body, querystring, params, and response using Fastify's built-in validation. This enforces contracts and aids OpenAPI generation.
XI. CORS & Rate Limiting:
CORS: fastify-cors configured with a restrictive production whitelist of allowed client origins.
Rate Limiting: fastify-rate-limit with defaults (e.g., 100 requests/minute/IP globally) and stricter limits on auth/search endpoints. Return 429 Too Many Requests with Retry-After header.
XII. Bulk Operations:
Bulk operations (e.g., POST /recipes with an array) are not supported in  unless an endpoint is specifically designed and documented for bulk actions. Attempting bulk operations on single-resource endpoints must return  with a message indicating bulk operations are not supported on that endpoint.
XIII. HATEOAS/Hypermedia (Minimal for MVP):
Full HATEOAS is out of scope for /v1. Minimal _links object in responses for self and key related resources is encouraged for discoverability. Pagination responses will use prevPageUrl/nextPageUrl in the body and standard HTTP Link headers.
XIV. Documentation (OpenAPI):
API documented using OpenAPI Specification (OAS) 3.x.
Use fastify-swagger to auto-generate OAS from Fastify route schemas. Published at /v1/openapi.json (UI at /v1/docs).
XV. File Uploads (e.g., Recipe Media):
Use POST or PUT to a dedicated media endpoint (e.g., /v1/recipes/{recipeId}/image-upload).
Content-Type: multipart/form-data. Body includes a file field.
Response: 201 Created or 200 OK with JSON body containing mediaUrl of the stored file and any other relevant metadata.
Error handling: 400 Bad Request if no file, 413 Payload Too Large, 415 Unsupported Media Type.
5. Rationale
These refined principles provide a comprehensive, consistent, secure, and developer-friendly framework for the WorldChef API, promoting best practices from the outset. Key additions like JSON Schema validation, robust caching/conditional request support, explicit PATCH semantics, defined file upload strategy, and enhanced HATEOAS/pagination links significantly improve the API's quality and usability for MVP and beyond.
6. Consequences
Positive Consequences / Benefits:
Highly consistent, predictable, robust, and secure API.
Excellent DX for client and backend developers.
Strong foundation for auto-generated, accurate documentation.
Improved performance through caching and partial responses.
Negative Consequences / Trade-offs / Risks:
Requires strong discipline and upfront effort to implement all principles consistently (mitigation: use Fastify's features, PR reviews, shared utilities/plugins for common patterns like error handling, pagination).
Initial setup for full OpenAPI generation, caching logic, and detailed schema validation takes time.
7. Validation / Success Metrics
All API endpoints adhere to defined principles (checked via PR reviews, automated linting where possible).
Fastify route schemas exist for all endpoints and are actively used for validation.
OpenAPI documentation is accurately auto-generated and consumable by client developers/tools.
Client developers report high ease of integration and understanding.
Performance benchmarks confirm effectiveness of caching, pagination, and field selection.
Security reviews validate secure implementation of auth, input validation, and error handling.
8. Review / Revisit
After significant portions of  Review adherence, DX, identify any principles causing friction or proving difficult to implement consistently.
Before designing 
Annually, to align with evolving API design best practices.


