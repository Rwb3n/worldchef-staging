ADR-WCF-008: Search Implementation Strategy
Status: ACCEPTED
Date: 2025-06-01 (Final version incorporating comprehensive feedback on FTS/trigram setup, diacritic/synonym handling, partial indexing, fallback logic, result highlighting, API considerations, monitoring, and multilingual strategy for MVP)
Authors: AI Dev Team
1. Context and Problem Statement
Effective recipe and creator discovery is crucial for WorldChef. For MVP, a foundational search capability is needed for users to find recipes (by keywords in title, description, cuisine, region, tags) and creators (by display name), with robust performance, relevance, and tolerance for typos and diacritics. This ADR documents the decision to use PostgreSQL's built-in Full-Text Search (FTS), pg_trgm extension, and unaccent extension.
2. Decision Drivers
Core MVP Discovery: Enable basic, effective keyword search.
Development Velocity & Simplicity (MVP): Minimize additional infrastructure.
Cost-Effectiveness (MVP): Avoid costs of dedicated search services.
Performance (MVP Scale): Deliver fast results (p95 latency for search API call < 500ms on <10k active, published recipes).
Data Consistency: Search live data directly from PostgreSQL.
Relevance, Typo & Diacritic Tolerance.
Integration with Structured Filters.
3. Considered Options
(Options remain: 1. PostgreSQL FTS + 
4. Decision
Chosen Option: Option 1: PostgreSQL Full-Text Search (FTS) with GIN indexing, complemented by the 
Implementation Details for MVP:
Enable Extensions in Supabase/PostgreSQL:
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS unaccent;
content_copy
download
Use code with caution.SQL

FTS Configuration & 
For 
ALTER TABLE recipes ADD COLUMN recipe_search_vector TSVECTOR;

CREATE OR REPLACE FUNCTION recipes_search_vector_update() RETURNS trigger AS $$
BEGIN
  -- Clear vector if recipe is not searchable, to keep vector small for non-published
  IF NEW.deleted_at IS NOT NULL OR NEW.status <> 'published' THEN
    NEW.recipe_search_vector := NULL;
  ELSE
    NEW.recipe_search_vector :=
      setweight(to_tsvector('pg_catalog.english', unaccent(coalesce(NEW.title,''))), 'A') ||
      setweight(to_tsvector('pg_catalog.english', unaccent(coalesce(NEW.description,''))), 'B') ||
      setweight(to_tsvector('pg_catalog.english', unaccent(coalesce(NEW.cuisine,''))), 'C') ||
      setweight(to_tsvector('pg_catalog.english', unaccent(coalesce(NEW.region,''))), 'C') ||
      setweight(to_tsvector('pg_catalog.english', unaccent(lower(array_to_string(NEW.diet, ' ')))), 'D') ||
      setweight(to_tsvector('pg_catalog.english', unaccent(lower(array_to_string(NEW.time_of_day, ' ')))), 'D');
  END IF;
  RETURN NEW;
END
$$ LANGUAGE STABLE LANGUAGE plpgsql;

CREATE TRIGGER tsvectorupdate_recipes BEFORE INSERT OR UPDATE
ON recipes FOR EACH ROW EXECUTE FUNCTION recipes_search_vector_update();
content_copy
download
Use code with caution.SQL

For 
ALTER TABLE creators ADD COLUMN creator_search_vector TSVECTOR;

CREATE OR REPLACE FUNCTION creators_search_vector_update() RETURNS trigger AS $$
BEGIN
  IF NEW.deleted_at IS NOT NULL OR NEW.status <> 'active' THEN
    NEW.creator_search_vector := NULL;
  ELSE
    NEW.creator_search_vector :=
      setweight(to_tsvector('pg_catalog.english', unaccent(coalesce(NEW.display_name,''))), 'A');
  END IF;
  RETURN NEW;
END
$$ LANGUAGE STABLE LANGUAGE plpgsql;

CREATE TRIGGER tsvectorupdate_creators BEFORE INSERT OR UPDATE
ON creators FOR EACH ROW EXECUTE FUNCTION creators_search_vector_update();
content_copy
download
Use code with caution.SQL

Tag Synonym Handling (MVP): For MVP, exact matches on array tags (after lower, unaccent) are supported. Advanced synonym mapping (e.g., "veggie" -> "vegetarian") will be handled at the Fastify API layer if needed, by expanding search queries or normalizing tags before FTS indexing.

Indexing (Partial Indexes for active/published content):
GIN indexes on tsvector columns:
CREATE INDEX recipes_search_idx_active ON recipes USING GIN (recipe_search_vector)
WHERE deleted_at IS NULL AND status = 'published'; -- Matches trigger logic

CREATE INDEX creators_search_idx_active ON creators USING GIN (creator_search_vector)
WHERE deleted_at IS NULL AND status = 'active'; -- Matches trigger logic
content_copy
download
Use code with caution.SQL

GIST/GIN indexes using pg_trgm (with unaccent):
CREATE INDEX recipes_title_trgm_idx_active ON recipes USING GIN (unaccent(title) gin_trgm_ops)
WHERE deleted_at IS NULL AND status = 'published';
-- Optional: CREATE INDEX recipes_description_trgm_idx_active ON recipes USING GIN (unaccent(description) gin_trgm_ops) WHERE deleted_at IS NULL AND status = 'published'; (If fuzzy on desc needed)

CREATE INDEX creators_display_name_trgm_idx_active ON creators USING GIN (unaccent(display_name) gin_trgm_ops)
WHERE deleted_at IS NULL AND status = 'active';
content_copy
download
Use code with caution.SQL


API Endpoint & Query Construction (Fastify - ADR-WCF-001c):
Search endpoint: GET /v1/search?q=<term>&type=<recipes|creators|all>&page=X&limit=Y&filter_...
Query Processing:
Sanitize/validate user input q. Prepare search_query_unaccented = unaccent(q).
Primary FTS query using websearch_to_tsquery('english', search_query_unaccented) against the relevant search_vector and partial index conditions.
Rank FTS results using ts_rank_cd(search_vector, query).
Result Highlighting/Snippets: For top N (e.g., 5-10) recipe results, Fastify API may include highlighted excerpts from description using ts_headline('english', unaccent(description), query, 'StartSel=<b>,StopSel=</b>,MaxWords=30,MinWords=15,HighlightAll=TRUE'). Performance impact of ts_headline will be benchmarked.
Fallback Logic for Poor FTS Results (MVP - Simplified):
If primary FTS query returns zero results, the API may execute a secondary query using pg_trgm similarity on unaccent(title) for recipes or unaccent(display_name) for creators: WHERE similarity(unaccent(column_name), search_query_unaccented) > 0.3 (threshold configurable).
These fallback results are presented as a distinct secondary set (e.g., "Did you mean...?" or "Broader matches:"). For MVP, complex merging and re-ranking of FTS + trigram results is avoided; they are treated as separate result tiers if fallback is triggered.


Pagination: Default limit=20, max limit=50. OFFSET/LIMIT for MVP. Requests exceeding max limit return an error or are capped. Deep pagination (e.g., page > 20) might be explicitly disallowed or warned about performance in API docs, with keyset pagination as a future enhancement.
Rate Limiting: Search endpoint rate-limited (e.g., max 5-10 searches/active second per user/IP) via Fastify middleware.

Multi-Language Support (MVP Limitation):
FTS configured for 'english'. For MVP, searches on non-English content will have suboptimal linguistic processing. The application will log query languages (if detectable from client headers or user profile) and content languages to inform future multilingual FTS strategy (e.g., language-specific tsvector columns and configurations).

5. Rationale
PostgreSQL FTS + pg_trgm + unaccent offers a robust, integrated, and cost-effective search solution for WorldChef's MVP.
Comprehensive for MVP: Handles keyword search, relevance, typo tolerance, diacritic insensitivity. Partial indexes ensure only relevant content is searched.
Data Consistency & Real-time Results.
Performance with Optimization: Proper indexing and trigger logic for tsvector maintenance.
Extensible: ts_headline for snippets, combination with structured filters. Fallback logic provides coverage.
This refined approach addresses key feedback, enhancing robustness for a better MVP search experience.
6. Consequences
Positive Consequences / Benefits:
No additional infrastructure/service costs for core search.
Real-time, consistent, and linguistically smarter search (for English MVP).
Good baseline search UX for MVP.
Negative Consequences / Trade-offs / Risks:
Scalability Limits (Very Large Scale): Accepted for MVP.
Advanced Feature Limitations: Lacks complex faceting, ML-ranking.
Database Load: Search adds load. (Mitigation: Efficient/partial indexing, monitoring. Read replicas if available/needed post-MVP).
Trigger Write Overhead: tsvector updates add minor overhead to recipe/creator writes. (Mitigation: Triggers are STABLE and efficient).
Complexity of Fallback Logic: If FTS + trigram merging were fully implemented, API logic would be more complex (simplified for MVP).
7. Validation / Success Metrics
Successful keyword search for recipes/creators, handling common typos and diacritics.
Search API p95 latency < 500ms for common queries on MVP dataset.
Relevance ranking provides useful ordering. ts_headline snippets (if implemented and performant) improve context.
Monitoring:
Average search query latency (FTS primary, trigram fallback separately if used).
Error rates for search API.
FTS index size/health (e.g., bloat via pgstattuple).
Alerts: (via APM/Supabase metrics - ADR-WCF-021)
If median FTS query time > 500ms for >5 minutes.
If p95 FTS query time > 800ms for >5 minutes.
If FTS index bloat > 20% or size > 1GB (trigger for VACUUM FULL or REINDEX during maintenance).

Track user search queries (terms, result counts, fallback activation) for analytics on search quality and to identify common synonyms or missed matches.

8. Review / Revisit
After Cycle 3 & User Feedback: Evaluate performance, relevance, user satisfaction, and logged search analytics.
If search latency consistently exceeds targets or DB load is problematic.
If strong user demand for advanced features (faceting, true multilingual stemming, synonyms) becomes a business priority.
When dataset grows significantly (>50k-100k active recipes).
At these points, migrating to a dedicated search service or implementing more advanced PostgreSQL search techniques will be considered.


