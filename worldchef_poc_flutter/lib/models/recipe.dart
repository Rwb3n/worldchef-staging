/* ANNOTATION_BLOCK_START
{
  "artifact_id": "flutter_recipe_models",
  "version_tag": "1.0.0",
  "g_created": 13,
  "g_last_modified": 13,
  "description": "Recipe data model with JSON serialization for WorldChef PoC Flutter implementation, designed to handle mock server API responses efficiently.",
  "artifact_type": "CODE_MODULE",
  "status_in_lifecycle": "DEVELOPMENT",
  "purpose_statement": "Provides type-safe data models for recipe objects with automatic JSON serialization/deserialization for API integration and local storage.",
  "key_logic_points": [
    "Immutable Recipe class with comprehensive field validation",
    "JSON serialization using json_annotation and json_serializable",
    "Null-safe implementation with proper default values",
    "DateTime parsing for createdAt field with ISO 8601 format",
    "Convenience methods for UI display (rating display, time formatting)",
    "Equality and hashCode implementation for value semantics"
  ],
  "interfaces_provided": [
    {
      "name": "Recipe",
      "interface_type": "DATA_MODEL",
      "details": "Immutable data class representing a recipe with all metadata",
      "notes": "Supports JSON serialization, copying with modifications, and display formatting"
    }
  ],
  "requisites": [
    { "description": "json_annotation package for serialization annotations", "type": "EXTERNAL_DEPENDENCY" },
    { "description": "Generated code from json_serializable via build_runner", "type": "CODE_GENERATION" }
  ],
  "external_dependencies": [
    { "name": "json_annotation", "version": "^4.8.1", "reason": "Provides annotations for JSON serialization code generation" }
  ],
  "internal_dependencies": [],
  "dependents": ["flutter_api_service", "flutter_recipe_list_screen", "flutter_recipe_detail_screen"],
  "linked_issue_ids": [],
  "quality_notes": {
    "unit_tests": "PENDING - Unit tests for serialization/deserialization planned",
    "manual_review_comment": "AI-generated model with comprehensive JSON handling, immutability patterns, and UI convenience methods. Code generation setup required."
  }
}
ANNOTATION_BLOCK_END */

import 'package:json_annotation/json_annotation.dart';

// This will be generated by build_runner
part 'recipe.g.dart';

/// Represents a recipe with all metadata and content information.
/// 
/// This model handles the JSON structure from the WorldChef mock API:
/// - Automatic JSON serialization/deserialization
/// - Immutable data structure with copyWith support
/// - Null-safe implementation with sensible defaults
/// - UI-friendly helper methods for display formatting
@JsonSerializable(explicitToJson: true)
class Recipe {
  /// Unique identifier for the recipe
  final int id;
  
  /// Schema version for API compatibility
  @JsonKey(name: 'schema_version')
  final int schemaVersion;
  
  /// Recipe title/name
  final String title;
  
  /// Detailed description of the recipe
  final String description;
  
  /// Cooking time in minutes
  final int cookTime;
  
  /// Preparation time in minutes  
  final int prepTime;
  
  /// Number of servings this recipe produces
  final int servings;
  
  /// Difficulty level (Easy, Medium, Hard)
  final String difficulty;
  
  /// Recipe category (Italian, Asian, Desserts, etc.)
  final String category;
  
  /// List of ingredients required
  final List<String> ingredients;
  
  /// URL to the recipe image
  final String imageUrl;
  
  /// Average rating (0.0 to 5.0)
  final double rating;
  
  /// Number of user reviews
  final int reviewCount;
  
  /// When the recipe was created (ISO 8601 format)
  final DateTime createdAt;

  const Recipe({
    required this.id,
    required this.schemaVersion,
    required this.title,
    required this.description,
    required this.cookTime,
    required this.prepTime,
    required this.servings,
    required this.difficulty,
    required this.category,
    required this.ingredients,
    required this.imageUrl,
    required this.rating,
    required this.reviewCount,
    required this.createdAt,
  });

  /// Creates a Recipe from JSON map (from API response)
  factory Recipe.fromJson(Map<String, dynamic> json) => _$RecipeFromJson(json);

  /// Converts Recipe to JSON map (for storage/transmission)
  Map<String, dynamic> toJson() => _$RecipeToJson(this);

  /// Creates a copy of this recipe with modified fields
  Recipe copyWith({
    int? id,
    int? schemaVersion,
    String? title,
    String? description,
    int? cookTime,
    int? prepTime,
    int? servings,
    String? difficulty,
    String? category,
    List<String>? ingredients,
    String? imageUrl,
    double? rating,
    int? reviewCount,
    DateTime? createdAt,
  }) {
    return Recipe(
      id: id ?? this.id,
      schemaVersion: schemaVersion ?? this.schemaVersion,
      title: title ?? this.title,
      description: description ?? this.description,
      cookTime: cookTime ?? this.cookTime,
      prepTime: prepTime ?? this.prepTime,
      servings: servings ?? this.servings,
      difficulty: difficulty ?? this.difficulty,
      category: category ?? this.category,
      ingredients: ingredients ?? this.ingredients,
      imageUrl: imageUrl ?? this.imageUrl,
      rating: rating ?? this.rating,
      reviewCount: reviewCount ?? this.reviewCount,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  // UI Helper Methods

  /// Total time for the recipe (prep + cook time)
  int get totalTime => prepTime + cookTime;

  /// Formatted total time string for UI display
  String get totalTimeFormatted {
    if (totalTime < 60) {
      return '${totalTime}m';
    } else {
      final hours = totalTime ~/ 60;
      final minutes = totalTime % 60;
      return minutes > 0 ? '${hours}h ${minutes}m' : '${hours}h';
    }
  }

  /// Formatted rating for UI display (e.g., "4.7")
  String get ratingFormatted => rating.toStringAsFixed(1);

  /// Formatted review count for UI display (e.g., "1.2k", "1245")
  String get reviewCountFormatted {
    if (reviewCount >= 1000) {
      final k = reviewCount / 1000;
      return '${k.toStringAsFixed(1)}k';
    }
    return reviewCount.toString();
  }

  /// Whether this is a quick recipe (total time <= 30 minutes)
  bool get isQuickRecipe => totalTime <= 30;

  /// Difficulty level for UI styling
  RecipeDifficulty get difficultyLevel {
    switch (difficulty.toLowerCase()) {
      case 'easy':
        return RecipeDifficulty.easy;
      case 'medium':
        return RecipeDifficulty.medium;
      case 'hard':
        return RecipeDifficulty.hard;
      default:
        return RecipeDifficulty.medium;
    }
  }

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Recipe &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          schemaVersion == other.schemaVersion;

  @override
  int get hashCode => id.hashCode ^ schemaVersion.hashCode;

  @override
  String toString() {
    return 'Recipe{id: $id, title: $title, rating: $rating, totalTime: ${totalTimeFormatted}}';
  }
}

/// Enum for recipe difficulty levels with UI-friendly properties
enum RecipeDifficulty {
  easy('Easy'),
  medium('Medium'), 
  hard('Hard');

  const RecipeDifficulty(this.displayName);
  
  final String displayName;
}

// API Response Models

/// Wrapper for recipe list API responses
@JsonSerializable(explicitToJson: true)
class RecipeListResponse {
  final List<Recipe> recipes;

  const RecipeListResponse({required this.recipes});

  factory RecipeListResponse.fromJson(Map<String, dynamic> json) => 
      _$RecipeListResponseFromJson(json);

  Map<String, dynamic> toJson() => _$RecipeListResponseToJson(this);

  /// Total number of recipes in this response
  int get count => recipes.length;

  /// Whether the response contains any recipes
  bool get isEmpty => recipes.isEmpty;
  bool get isNotEmpty => recipes.isNotEmpty;
}

/// Wrapper for single recipe API responses  
@JsonSerializable(explicitToJson: true)
class RecipeDetailResponse {
  final Recipe recipe;

  const RecipeDetailResponse({required this.recipe});

  factory RecipeDetailResponse.fromJson(Map<String, dynamic> json) =>
      _$RecipeDetailResponseFromJson(json);

  Map<String, dynamic> toJson() => _$RecipeDetailResponseToJson(this);
}

// Example Usage (for documentation):
/*
// Parse recipe list from API
final jsonResponse = await http.get('/recipes');
final listResponse = RecipeListResponse.fromJson(jsonDecode(jsonResponse.body));
final recipes = listResponse.recipes;

// Parse single recipe from API
final recipeJson = await http.get('/recipes/1');
final recipe = Recipe.fromJson(jsonDecode(recipeJson.body));

// Create modified copy
final updatedRecipe = recipe.copyWith(rating: 4.8);

// UI display helpers
Text(recipe.ratingFormatted); // "4.7"
Text(recipe.totalTimeFormatted); // "40m" or "1h 15m"
Text(recipe.reviewCountFormatted); // "1.2k"
*/ 